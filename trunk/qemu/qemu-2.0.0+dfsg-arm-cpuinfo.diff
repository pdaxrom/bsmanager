./configure --target-list=arm-linux-user,aarch64-linux-user --prefix=/usr --static --interp-prefix=/etc/qemu-binfmt/%M

diff -Nur qemu-2.0.0+dfsg-orig/config.status qemu-2.0.0+dfsg/config.status
--- qemu-2.0.0+dfsg-orig/config.status	1970-01-01 04:00:00.000000000 +0400
+++ qemu-2.0.0+dfsg/config.status	2015-03-10 13:42:37.116099480 +0400
@@ -0,0 +1,6 @@
+#!/bin/sh
+# Generated by configure.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+exec './configure' '--target-list=arm-linux-user,aarch64-linux-user' '--prefix=/usr' '--static' '--interp-prefix=/etc/qemu-binfmt/%M'
diff -Nur qemu-2.0.0+dfsg-orig/linux-user/syscall.c qemu-2.0.0+dfsg/linux-user/syscall.c
--- qemu-2.0.0+dfsg-orig/linux-user/syscall.c	2014-04-17 17:30:59.000000000 +0400
+++ qemu-2.0.0+dfsg/linux-user/syscall.c	2015-03-10 14:15:14.128017179 +0400
@@ -5139,6 +5139,99 @@
     return 0;
 }
 
+#ifdef TARGET_ARM
+static int open_proc_cpuinfo(void *cpu_env, int fd)
+{
+
+#ifdef TARGET_AARCH64
+    const char *info =
+"Processor	: AArch64 Processor rev 0 (aarch64)\n"
+"processor	: 0\n"
+"BogoMIPS	: 200.00\n"
+"processor	: 1\n"
+"BogoMIPS	: 200.00\n"
+"\n"
+"Features	: fp asimd\n"
+"CPU implementer: 0x41\n"
+"CPU architecture: AArch64\n"
+"CPU variant	: 0x0\n"
+"CPU part	: 0xd00\n"
+"CPU revision	: 0\n"
+"\n"
+"Hardware	: V2P-AARCH64\n";
+#else
+    const char *info;
+
+    const char *armv7 =
+"Processor	: ARMv7 Processor rev 4 (v7l)\n"
+"processor	: 0\n"
+"BogoMIPS	: 1810.43\n"
+"processor	: 1\n"
+"BogoMIPS	: 1823.53\n"
+"\n"
+"Features	: swp half thumb fastmult vfp edsp thumbee neon vfpv3 tls vfpv4 idiva idivt\n"
+"CPU implementer: 0x41\n"
+"CPU architecture: 7\n"
+"CPU variant	: 0x0\n"
+"CPU part	: 0xc07\n"
+"CPU revision	: 4\n"
+"\n"
+"Hardware	: sun7i\n"
+"Revision	: 0000\n";
+
+    const char *armv6 =
+"Processor	: ARMv6-compatible processor rev 7 (v6l)\n"
+"processor	: 0\n"
+"BogoMIPS	: 697.95\n"
+"processor	: 1\n"
+"BogoMIPS	: 697.95\n"
+"\n"
+"Features	: swp half thumb fastmult vfp edsp java tls\n"
+"CPU implementer: 0x41\n"
+"CPU architecture: 7\n"
+"CPU variant	: 0x0\n"
+"CPU part	: 0xb76\n"
+"CPU revision	: 7\n"
+"\n"
+"Hardware	: BCM2708\n"
+"Revision	: 0003\n"
+"Serial		: 0000000000000000\n";
+
+    const char *armv5 =
+"model name	: Feroceon 88FR131 rev 1 (v5l)\n"
+"processor	: 0\n"
+"BogoMIPS	: 996.14\n"
+"processor	: 1\n"
+"BogoMIPS	: 996.14\n"
+"\n"
+"Features	: swp half thumb fastmult edsp\n"
+"CPU implementer: 0x56\n"
+"CPU architecture: 5TE\n"
+"CPU variant	: 0x2\n"
+"CPU part	: 0x131\n"
+"CPU revision	: 1\n"
+"\n"
+"Hardware	: DNS-320L\n"
+"Revision	: 0000\n"
+"Serial		: 0000000000000000\n";
+
+    if (arm_feature(cpu_env, ARM_FEATURE_V7))
+        info = armv7;
+    else if (arm_feature(cpu_env, ARM_FEATURE_V6))
+        info = armv6;
+    else
+        info = armv5;
+#endif
+
+    int r = write(fd, info, strlen(info));
+    if (r > 0) {
+        lseek(fd, 0, SEEK_SET);
+    }
+
+    return 0;
+}
+#endif
+
 static int is_proc_myself(const char *filename, const char *entry)
 {
     if (!strncmp(filename, "/proc/", strlen("/proc/"))) {
@@ -5163,12 +5256,14 @@
     return 0;
 }
 
-#if defined(HOST_WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)
+#if (defined(HOST_WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)) || defined(TARGET_ARM)
 static int is_proc(const char *filename, const char *entry)
 {
     return strcmp(filename, entry) == 0;
 }
+#endif
 
+#if defined(HOST_WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)
 static int open_net_route(void *cpu_env, int fd)
 {
     FILE *fp;
@@ -5219,6 +5314,9 @@
         { "maps", open_self_maps, is_proc_myself },
         { "stat", open_self_stat, is_proc_myself },
         { "auxv", open_self_auxv, is_proc_myself },
+#ifdef TARGET_ARM
+        { "/proc/cpuinfo", open_proc_cpuinfo, is_proc },
+#endif
 #if defined(HOST_WORDS_BIGENDIAN) != defined(TARGET_WORDS_BIGENDIAN)
         { "/proc/net/route", open_net_route, is_proc },
 #endif
@@ -5259,6 +5357,57 @@
     return get_errno(open(path(pathname), flags, mode));
 }
 
+#if defined(TARGET_NR_openat) && defined(__NR_openat)
+static int do_openat(int dirfd, void *cpu_env, const char *pathname, int flags, mode_t mode)
+{
+#ifdef TARGET_AARCH64
+    struct fake_open {
+        const char *filename;
+        int (*fill)(void *cpu_env, int fd);
+        int (*cmp)(const char *s1, const char *s2);
+    };
+    const struct fake_open *fake_open;
+    static const struct fake_open fakes[] = {
+        { "/proc/cpuinfo", open_proc_cpuinfo, is_proc },
+        { NULL, NULL, NULL }
+    };
+
+    for (fake_open = fakes; fake_open->filename; fake_open++) {
+        if (fake_open->cmp(pathname, fake_open->filename)) {
+            break;
+        }
+    }
+
+    if (fake_open->filename) {
+        const char *tmpdir;
+        char filename[PATH_MAX];
+        int fd, r;
+
+        /* create temporary file to map stat to */
+        tmpdir = getenv("TMPDIR");
+        if (!tmpdir)
+            tmpdir = "/tmp";
+        snprintf(filename, sizeof(filename), "%s/qemu-open.XXXXXX", tmpdir);
+        fd = mkstemp(filename);
+        if (fd < 0) {
+            return fd;
+        }
+        unlink(filename);
+
+        if ((r = fake_open->fill(cpu_env, fd))) {
+            close(fd);
+            return r;
+        }
+        lseek(fd, 0, SEEK_SET);
+
+        return fd;
+    }
+#endif
+
+    return get_errno(sys_openat(dirfd, path(pathname), flags, mode));
+}
+#endif
+
 /* do_syscall() should always have a single exit point at the end so
    that actions, such as logging of syscall results, can be performed.
    All errnos that do_syscall() returns must be -TARGET_<errcode>. */
@@ -5340,8 +5489,7 @@
     case TARGET_NR_openat:
         if (!(p = lock_user_string(arg2)))
             goto efault;
-        ret = get_errno(sys_openat(arg1,
-                                   path(p),
+        ret = get_errno(do_openat(arg1, cpu_env, p,
                                    target_to_host_bitmask(arg3, fcntl_flags_tbl),
                                    arg4));
         unlock_user(p, arg2, 0);
